***********
prysm v0.21
***********

New Features
============

Raytracing has been implemented using Spencer & Murty's icionic method.  Tracing multiple rays in parallel is supported, as are surfaced based on all of the polynomials implemented in prysm (sphere, conic, even asphere, Zernike, Qbfs, Qcon, Q2D, Hermite, Legendre, Chebyshev, ...).  Individual rays trace at a rate of about 5,000 ray-surfaces per second on a laptop CPU.  Roughly 2.5 million ray-surfaces per second are acheived on a laptop CPU with batched calculations and low complexity surfaces (conics, spheres).  More complex surface geometries, e.g. Q polynomials are slower.  Batch raytracing on GPU traces several billion ray-surfaces per second, exceeding the performance of Zemax and Code V.  There is no support for optimization, either now or planned.  Basic analysis routines are included -- spot diagrams, transverse ray aberrations, as well as paraxial image solves.  2D raytrace plots are supported.  The raytracing module will be expanded in the future and integration between it and the physical optics routines will be performed, enabling hybrid modeling with both rays and waves.

Segmented systems have gained support for highly optimized modal wavefront errors by using :func:`prysm.segmented.CompositeHexagonalAperture.prepare_opd_bases` and :func:`prysm.segmented.CompositeHexagonalAperture.compose_opd`.  On a laptop CPU, it takes less than 3 milliseconds to do an 11 term Zernike expansion of each segment in a JWST-like aperture on a 512x512 array.

The polynomials module has gained support for both types of Hermite polynomials, Dickson polynomials of the first and second kind, and Chebyshev polynomials of the third and Fourth kind:

* :func:`~prysm.polynomials.hermite_He`
* :func:`~prysm.polynomials.hermite_He_sequence`
* :func:`~prysm.polynomials.hermite_H`
* :func:`~prysm.polynomials.hermite_H_sequence`
* :func:`~prysm.polynomials.dickson1`
* :func:`~prysm.polynomials.dickson1_sequence`
* :func:`~prysm.polynomials.dickson2`
* :func:`~prysm.polynomials.dickson1_sequence`
* :func:`~prysm.polynomials.cheby3`
* :func:`~prysm.polynomials.cheby3_sequence`
* :func:`~prysm.polynomials.cheby4`
* :func:`~prysm.polynomials.cheby4_sequence`

First derivatives of many types of polynomials and their descendants are also now available:

* :func:`~prysm.polynomials.jacobi_der`
* :func:`~prysm.polynomials.jacobi_der_sequence`
* :func:`~prysm.polynomials.cheby1_der`
* :func:`~prysm.polynomials.cheby1_der_sequence`
* :func:`~prysm.polynomials.cheby2_der`
* :func:`~prysm.polynomials.cheby2_der_sequence`
* :func:`~prysm.polynomials.cheby3_der`
* :func:`~prysm.polynomials.cheby3_der_sequence`
* :func:`~prysm.polynomials.cheby4_der`
* :func:`~prysm.polynomials.cheby4_der_sequence`
* :func:`~prysm.polynomials.zernike_der`
* :func:`~prysm.polynomials.zernike_der_sequence`
* :func:`~prysm.polynomials.Qbfs_der`
* :func:`~prysm.polynomials.Qbfs_der_sequence`
* :func:`~prysm.polynomials.Qcon_der`
* :func:`~prysm.polynomials.Qcon_der_sequence`
* :func:`~prysm.polynomials.Q2d_der`
* :func:`~prysm.polynomials.Q2d_der_sequence`

These are useful for applications such as raytracing.

Bug Fixes
=========

:class:`~prysm.segmented.CompositeHexagonalAperture` internal data structures did not exclude the center/0th segment, even if the amplitude mask did.  This has been fixed.


Performance Enhancements
========================

the thinfilm module's multilayer stack function has been vectorized, allowing arrays of thicknesses and indices to be used, instead of single points.  This enables the calculation to be batched over ranges of thicknesses, as e.g. for spatial distributions of thickness or thickness sweeps for design optimization.  For the 54x54 computation of the Roman Coronagraph Instrument's Hybrid Lyot occulter, the computation is 100x faster batched than elementwise.  Use the function in the same way, except when defining your stack instead of having scalar (n, d) for each layer use arbitrarily dimensional arrays.

The performance Jacobi polynomial computations has been increased by 18%.  This cascades to performance of Chebyshev, Legendre, and Zernike polynomials.  The increase comes from replacing an outdated recurrence relation for one expressed in the standard form, which happens to be a bit faster.
