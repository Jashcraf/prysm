***********
prysm v0.21
***********

New Features
============

The polynomials module has gained support for the dickson polynomials of the first and second kind, and Chebyshev polynomials of the third and Fourth kind:

* :func:`~prysm.polynomials.dickson1`
* :func:`~prysm.polynomials.dickson1_sequence`
* :func:`~prysm.polynomials.dickson2`
* :func:`~prysm.polynomials.dickson1_sequence`
* :func:`~prysm.polynomials.cheby3`
* :func:`~prysm.polynomials.cheby3_sequence`
* :func:`~prysm.polynomials.cheby4`
* :func:`~prysm.polynomials.cheby4_sequence`

First derivatives of jacobi polynomials and their descendants are also now available:

* :func:`~prysm.polynomials.jacobi_der`
* :func:`~prysm.polynomials.jacobi_der_sequence`
* :func:`~prysm.polynomials.cheby1_der`
* :func:`~prysm.polynomials.cheby1_der_sequence`
* :func:`~prysm.polynomials.cheby2_der`
* :func:`~prysm.polynomials.cheby2_der_sequence`
* :func:`~prysm.polynomials.cheby3_der`
* :func:`~prysm.polynomials.cheby3_der_sequence`
* :func:`~prysm.polynomials.cheby4_der`
* :func:`~prysm.polynomials.cheby4_der_sequence`
* :func:`~prysm.polynomials.zernike_der`
* :func:`~prysm.polynomials.zernike_der_sequence`
* :func:`~prysm.polynomials.Qbfs_der`
* :func:`~prysm.polynomials.Qbfs_der_sequence`
* :func:`~prysm.polynomials.Qcon_der`
* :func:`~prysm.polynomials.Qcon_der_sequence`
* :func:`~prysm.polynomials.Q2d_der`
* :func:`~prysm.polynomials.Q2d_der_sequence`

These are usefor for applications such as raytracing.

The performance Jacobi polynomial computations has been increased by 18%.  This cascades to performance of Chebyshev, Legendre, and Zernike polynomials.  The increase comes from replacing an outdated recurrence relation for one expressed in the standard form, which happens to be a bit faster.


Performance Enhancements
========================

the thinfilm module's multilayer stack function has been vectorized, allowing arrays of thicknesses and indices to be used, instead of single points.  This enables the calculation to be batched over ranges of thicknesses, as e.g. for spatial distributions of thickness or thickness sweeps for design optimization.  For the 54x54 computation of the Roman Coronagraph Instrument's Hybrid Lyot occulter, the computation is 100x faster batched than elementwise.  Use the function in the same way, except when defining your stack instead of having scalar (n, d) for each layer use arbitrarily dimensional arrays.
